# main.py
import os
import re
import asyncio
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv
import aiosqlite

from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.filters.state import StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.state import State, StatesGroup

# --- –ö–æ–Ω—Ñ—ñ–≥ —Ç–∞ –ª–æ–≥
load_dotenv()
logging.basicConfig(level=logging.INFO)
API_TOKEN = os.getenv("BOT_TOKEN")
if not API_TOKEN:
    raise RuntimeError("BOT_TOKEN –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≤ –∑–º—ñ–Ω–Ω–∏—Ö –æ—Ç–æ—á–µ–Ω–Ω—è. –î–æ–¥–∞–π—Ç–µ BOT_TOKEN —É .env –∞–±–æ –≤ –æ—Ç–æ—á–µ–Ω–Ω—è —Å–µ—Ä–≤–µ—Ä–∞.")

DB_PATH = os.path.join(os.path.dirname(__file__), "db.sqlite3")

# --- Bot & Dispatcher
storage = MemoryStorage()
bot = Bot(token=API_TOKEN)
dp = Dispatcher(storage=storage)

# --- –ö–ª–∞–≤—ñ–∞—Ç—É—Ä–∞ (reply)
main_keyboard = types.ReplyKeyboardMarkup(
    keyboard=[
        [types.KeyboardButton(text="üì• –î–æ–¥–∞—Ç–∏ –∑–∞—Ä–æ–±—ñ—Ç–æ–∫"), types.KeyboardButton(text="üí∏ –î–æ–¥–∞—Ç–∏ –≤–∏—Ç—Ä–∞—Ç–∏")],
        [types.KeyboardButton(text="üìä –ú–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"), types.KeyboardButton(text="üìÖ –ó–≤—ñ—Ç –∑–∞ –ø–µ—Ä—ñ–æ–¥")],
        [types.KeyboardButton(text="üèÜ –¢–æ–ø –≤–æ–¥—ñ—ó–≤"), types.KeyboardButton(text="üöò –ú—ñ–π –∞–≤—Ç–æ–º–æ–±—ñ–ª—å")],
        [types.KeyboardButton(text="‚öôÔ∏è –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è")],
    ],
    resize_keyboard=True
)

# --- –°—Ç–∞–Ω–æ–≤–∞ –º–∞—à–∏–Ω–∞ –¥–ª—è —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó + –¥–æ–¥–∞–≤–∞–Ω–Ω—è —Ñ—ñ–Ω–∞–Ω—Å—ñ–≤
class Registration(StatesGroup):
    waiting_for_name = State()
    waiting_for_nickname = State()
    waiting_for_car_model = State()
    waiting_for_car_number = State()

class AddIncome(StatesGroup):
    waiting_for_amount = State()

class AddExpense(StatesGroup):
    waiting_for_amount = State()
    waiting_for_type = State()

# --- –ü–∞—Ç—Ç–µ—Ä–Ω–∏ —Ç–∞ –¥–æ–ø–æ–º—ñ–∂–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó
PLATE_RE = re.compile(r'^[A-Z–ê-–Ø]{2}\d{4}[A-Z–ê-–Ø]{2}$', re.I)  # –¥–æ–∑–≤–æ–ª—è—î –ª–∞—Ç/–∫–∏—ó–≤—Å—å–∫—ñ –ª—ñ—Ç–µ—Ä–∏
def normalize_plate(text: str) -> str:
    return text.strip().upper().replace(" ", "")

def is_valid_money(text: str) -> bool:
    try:
        v = float(text.replace(",", "."))
        return v > 0
    except:
        return False

def parse_money(text: str) -> float:
    return float(text.replace(",", "."))

# --- –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —Ç–∞ –∑–∞–ø–∏—Ç–∏ –¥–æ –ë–î ---
async def init_db():
    async with aiosqlite.connect(DB_PATH) as db:
        await db.executescript("""
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            tg_first_name TEXT,
            name TEXT,
            nickname TEXT UNIQUE,
            car_model TEXT,
            car_number TEXT,
            lang TEXT DEFAULT 'uk',
            report_period TEXT DEFAULT 'weekly',
            registered_at TEXT
        );

        CREATE TABLE IF NOT EXISTS incomes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            amount REAL,
            ts TEXT,
            note TEXT,
            FOREIGN KEY(user_id) REFERENCES users(user_id)
        );

        CREATE TABLE IF NOT EXISTS expenses (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            amount REAL,
            type TEXT,
            ts TEXT,
            note TEXT,
            FOREIGN KEY(user_id) REFERENCES users(user_id)
        );
        """)
        await db.commit()

async def fetchone(query, params=()):
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(query, params)
        row = await cur.fetchone()
        return row

async def execute(query, params=()):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(query, params)
        await db.commit()

# --- –Æ–∑–µ—Ä-—Ñ—É–Ω–∫—Ü—ñ—ó ---
async def user_exists(user_id: int) -> bool:
    r = await fetchone("SELECT 1 FROM users WHERE user_id = ?", (user_id,))
    return r is not None

async def save_user(user_id: int, tg_first_name: str, data: dict):
    now = datetime.utcnow().isoformat()
    await execute("""
        INSERT OR REPLACE INTO users (user_id, tg_first_name, name, nickname, car_model, car_number, registered_at)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    """, (user_id, tg_first_name, data.get("name"), data.get("nickname"), data.get("car_model"), data.get("car_number"), now))

async def nickname_exists(nickname: str) -> bool:
    r = await fetchone("SELECT 1 FROM users WHERE LOWER(nickname)=LOWER(?)", (nickname,))
    return r is not None

# --- –ë–∞–ª–∞–Ω—Å —ñ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ ---
async def get_balance(user_id:int, since: datetime=None):
    async with aiosqlite.connect(DB_PATH) as db:
        if since:
            ts = since.isoformat()
            cur_in = await db.execute("SELECT COALESCE(SUM(amount),0) FROM incomes WHERE user_id=? AND ts>=?", (user_id, ts))
            cur_ex = await db.execute("SELECT COALESCE(SUM(amount),0) FROM expenses WHERE user_id=? AND ts>=?", (user_id, ts))
        else:
            cur_in = await db.execute("SELECT COALESCE(SUM(amount),0) FROM incomes WHERE user_id=?", (user_id,))
            cur_ex = await db.execute("SELECT COALESCE(SUM(amount),0) FROM expenses WHERE user_id=?", (user_id,))
        total_in = (await cur_in.fetchone())[0] or 0.0
        total_ex = (await cur_ex.fetchone())[0] or 0.0
        return total_in, total_ex, total_in - total_ex

# --- –†–µ–π—Ç–∏–Ω–≥–∏ ---
async def get_top_drivers(limit=10):
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("""
            SELECT u.nickname, u.name, COALESCE(SUM(i.amount),0) - COALESCE(SUM(e.amount),0) AS balance
            FROM users u
            LEFT JOIN incomes i ON i.user_id = u.user_id
            LEFT JOIN expenses e ON e.user_id = u.user_id
            GROUP BY u.user_id
            ORDER BY balance DESC
            LIMIT ?
        """, (limit,))
        rows = await cur.fetchall()
        return rows

# --- –û–±—Ä–æ–±–Ω–∏–∫–∏: —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—è / —Å—Ç–∞—Ä—Ç ---
async def cmd_start(message: types.Message, state: FSMContext):
    await state.clear()
    uid = message.from_user.id
    if await user_exists(uid):
        await message.answer(f"–ó –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è–º, {message.from_user.first_name}!", reply_markup=main_keyboard)
    else:
        await message.answer("–í—ñ—Ç–∞—é! –©–æ–± –ø–æ—á–∞—Ç–∏, –≤–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ —Å–ø—Ä–∞–≤–∂–Ω—î —ñ–º'—è:")
        await state.set_state(Registration.waiting_for_name)

async def process_name(message: types.Message, state: FSMContext):
    await state.update_data(name=message.text.strip())
    await message.answer("–ü—Ä–∏–¥—É–º–∞–π—Ç–µ —É–Ω—ñ–∫–∞–ª—å–Ω–∏–π –ø—Å–µ–≤–¥–æ–Ω—ñ–º (–≤—ñ–Ω –±—É–¥–µ –Ω–µ–∑–º—ñ–Ω–Ω–∏–π):")
    await state.set_state(Registration.waiting_for_nickname)

async def process_nickname(message: types.Message, state: FSMContext):
    nick = message.text.strip()
    if await nickname_exists(nick):
        await message.answer("–¶–µ–π –ø—Å–µ–≤–¥–æ–Ω—ñ–º –≤–∂–µ –∑–∞–π–Ω—è—Ç–∏–π. –û–±–µ—Ä—ñ—Ç—å —ñ–Ω—à–∏–π:")
        return
    await state.update_data(nickname=nick)
    await message.answer("–í–∫–∞–∂—ñ—Ç—å –º–∞—Ä–∫—É —Ç–∞ –º–æ–¥–µ–ª—å –∞–≤—Ç–æ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥ Renault Logan):")
    await state.set_state(Registration.waiting_for_car_model)

async def process_car_model(message: types.Message, state: FSMContext):
    await state.update_data(car_model=message.text.strip())
    await message.answer("–í–∫–∞–∂—ñ—Ç—å –Ω–æ–º–µ—Ä –∞–≤—Ç–æ–º–æ–±—ñ–ª—è (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥ BC1234AB):")
    await state.set_state(Registration.waiting_for_car_number)

async def process_car_number(message: types.Message, state: FSMContext):
    plate = normalize_plate(message.text)
    if not PLATE_RE.match(plate):
        await message.answer("–ù–µ–≤—ñ—Ä–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞. –°–ø—Ä–æ–±—É–π—Ç–µ —É —Ñ–æ—Ä–º–∞—Ç—ñ BC1234AB (–±–µ–∑ –ø—Ä–æ–±—ñ–ª—ñ–≤).")
        return
    await state.update_data(car_number=plate)
    data = await state.get_data()
    await save_user(message.from_user.id, message.from_user.first_name, data)
    await message.answer("‚úÖ –†–µ—î—Å—Ç—Ä–∞—Ü—ñ—é –∑–∞–≤–µ—Ä—à–µ–Ω–æ!", reply_markup=main_keyboard)
    await state.clear()

# --- –û–±—Ä–æ–±–Ω–∏–∫–∏ –∫–Ω–æ–ø–æ–∫: –¥–æ–¥–∞—Ç–∏ –¥–æ—Ö–æ–¥/–≤–∏—Ç—Ä–∞—Ç–∏ —ñ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ ---
async def add_income_start(message: types.Message, state: FSMContext):
    if not await user_exists(message.from_user.id):
        await message.answer("–í–∏ –Ω–µ –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω—ñ. –ù–∞–¥—ñ—à–ª—ñ—Ç—å /start —â–æ–± –∑–∞—Ä–µ—î—Å—Ç—Ä—É–≤–∞—Ç–∏—Å—è.")
        return
    await message.answer("–í–≤–µ–¥—ñ—Ç—å —Å—É–º—É –¥–æ—Ö–æ–¥—É (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥ 250.50):")
    await state.set_state(AddIncome.waiting_for_amount)

async def add_income_amount(message: types.Message, state: FSMContext):
    if not is_valid_money(message.text):
        await message.answer("–ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–∞ —Å—É–º–∞. –í–≤–µ–¥—ñ—Ç—å —á–∏—Å–ª–æ > 0.")
        return
    amount = parse_money(message.text)
    ts = datetime.utcnow().isoformat()
    await execute("INSERT INTO incomes (user_id, amount, ts, note) VALUES (?, ?, ?, ?)", (message.from_user.id, amount, ts, None))
    await message.answer(f"–î–æ–¥–∞–Ω–æ –¥–æ –¥–æ—Ö–æ–¥—ñ–≤: {amount:.2f}", reply_markup=main_keyboard)
    await state.clear()

async def add_expense_start(message: types.Message, state: FSMContext):
    if not await user_exists(message.from_user.id):
        await message.answer("–í–∏ –Ω–µ –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω—ñ. –ù–∞–¥—ñ—à–ª—ñ—Ç—å /start —â–æ–± –∑–∞—Ä–µ—î—Å—Ç—Ä—É–≤–∞—Ç–∏—Å—è.")
        return
    await message.answer("–í–≤–µ–¥—ñ—Ç—å —Å—É–º—É –≤–∏—Ç—Ä–∞—Ç–∏ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥ 50.00):")
    await state.set_state(AddExpense.waiting_for_amount)

async def add_expense_amount(message: types.Message, state: FSMContext):
    if not is_valid_money(message.text):
        await message.answer("–ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–∞ —Å—É–º–∞. –í–≤–µ–¥—ñ—Ç—å —á–∏—Å–ª–æ > 0.")
        return
    await state.update_data(exp_amount=parse_money(message.text))
    # –ø–æ–∫–∞–∑—É—î–º–æ –≤–∞—Ä—ñ–∞–Ω—Ç–∏ —Ç–∏–ø—ñ–≤ –≤–∏—Ç—Ä–∞—Ç inline
    kb = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="–ü–∞–ª–∏–≤–æ", callback_data="exp_type:fuel"),
         types.InlineKeyboardButton(text="–ú–∏–π–∫–∞", callback_data="exp_type:wash")],
        [types.InlineKeyboardButton(text="–†–µ–º–æ–Ω—Ç", callback_data="exp_type:repair"),
         types.InlineKeyboardButton(text="–Ü–Ω—à–µ", callback_data="exp_type:other")]
    ])
    await message.answer("–û–±–µ—Ä—ñ—Ç—å —Ç–∏–ø –≤–∏—Ç—Ä–∞—Ç–∏:", reply_markup=kb)
    await state.set_state(AddExpense.waiting_for_type)

async def exp_type_callback(callback: types.CallbackQuery, state: FSMContext):
    await callback.answer()
    data = await state.get_data()
    amount = data.get("exp_amount")
    if amount is None:
        await callback.message.answer("–ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ —Å—É–º—É. –ü–æ—á–Ω—ñ—Ç—å –∑–∞–Ω–æ–≤–æ.")
        await state.clear()
        return
    _, type_cb = callback.data.split(":", 1)
    ts = datetime.utcnow().isoformat()
    await execute("INSERT INTO expenses (user_id, amount, type, ts, note) VALUES (?, ?, ?, ?, ?)",
                  (callback.from_user.id, amount, type_cb, ts, None))
    await callback.message.answer(f"–î–æ–¥–∞–Ω–æ –≤–∏—Ç—Ä–∞—Ç—É {amount:.2f} ({type_cb})", reply_markup=main_keyboard)
    await state.clear()

# --- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: –¥–µ–Ω—å/—Ç–∏–∂–¥–µ–Ω—å/–º—ñ—Å—è—Ü—å —Ç–∞ –¥–æ–≤—ñ–ª—å–Ω–∏–π –ø–µ—Ä—ñ–æ–¥ ---
async def my_stats_handler(message: types.Message, state: FSMContext):
    uid = message.from_user.id
    if not await user_exists(uid):
        await message.answer("–í–∏ –Ω–µ –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω—ñ. –ù–∞–¥—ñ—à–ª—ñ—Ç—å /start —â–æ–± –∑–∞—Ä–µ—î—Å—Ç—Ä—É–≤–∞—Ç–∏—Å—è.")
        return
    now = datetime.utcnow()
    day_from = now - timedelta(days=1)
    week_from = now - timedelta(days=7)
    month_from = now - timedelta(days=30)
    din, dex, dbal = await get_balance(uid, since=day_from)
    win, wex, wbal = await get_balance(uid, since=week_from)
    minc, mexp, mbal = await get_balance(uid, since=month_from)
    total_in, total_ex, total_balance = await get_balance(uid, since=None)
    text = (
        f"–ë–∞–ª–∞–Ω—Å –∑–∞–≥–∞–ª—å–Ω–∏–π: {total_balance:.2f}\n"
        f"–°—å–æ–≥–æ–¥–Ω—ñ: +{din:.2f} -{dex:.2f} = {dbal:.2f}\n"
        f"–¢–∏–∂–¥–µ–Ω—å: +{win:.2f} -{wex:.2f} = {wbal:.2f}\n"
        f"–ú—ñ—Å—è—Ü—å: +{minc:.2f} -{mexp:.2f} = {mbal:.2f}"
    )
    await message.answer(text, reply_markup=main_keyboard)

# --- –ó–≤—ñ—Ç –∑–∞ –ø–µ—Ä—ñ–æ–¥: –∑–∞–ø–∏—Ç –¥–∞—Ç (–ø—Ä–æ—Å—Ç–æ—Ç–∞: YYYY-MM-DD) ---
async def report_period_start(message: types.Message, state: FSMContext):
    await message.answer("–í–≤–µ–¥—ñ—Ç—å –ø–æ—á–∞—Ç–∫–æ–≤—É –¥–∞—Ç—É —É —Ñ–æ—Ä–º–∞—Ç—ñ YYYY-MM-DD:")
    await state.set_state(State().set_state)  # —Ç–∏–º—á–∞—Å–æ–≤–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –∑–∞–≥–∞–ª—å–Ω–∏–π —Å—Ç–∞–Ω
    # –∞–ª–µ –∫—Ä–∞—â–µ —Ä–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ –æ–∫—Ä–µ–º—É StatesGroup –¥–ª—è –∑–≤—ñ—Ç—ñ–≤. –î–ª—è —Å—Ç–∏—Å–ª–æ—Å—Ç—ñ –Ω–∏–∂—á–µ ‚Äî –ø—Ä–æ—Å—Ç–∏–π –ø—ñ–¥—Ö—ñ–¥.

# –î–æ–¥–∞—Ç–∫–æ–≤–æ ‚Äî —Å–ø—Ä–æ—Å—Ç–∏–º–æ: –æ–±—Ä–æ–±–Ω–∏–∫ –∑ regex –Ω–∞ –¥–∞—Ç—É
async def report_period_handler(message: types.Message, state: FSMContext):
    # –æ—á—ñ–∫—É—î–º–æ –¥–≤–∞ —Ä—è–¥–∫–∏: start,end –∞–±–æ —Ñ–æ—Ä–º–∞—Ç –æ–±—Ä–æ–±–∫–∏ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ ‚Äî —Ç—É—Ç –¥–ª—è –ø—Ä–æ—Å—Ç–æ—ó UX –ø–æ–ø—Ä–æ—Å–∏–º–æ –≤–≤–µ—Å—Ç–∏ —è–∫ "YYYY-MM-DD,YYYY-MM-DD"
    txt = message.text.strip()
    parts = [p.strip() for p in txt.split(",") if p.strip()]
    if len(parts) != 2:
        await message.answer("–ù–µ–≤—ñ—Ä–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç. –ù–∞–¥—ñ—à–ª—ñ—Ç—å —É –≤–∏–≥–ª—è–¥—ñ: 2025-01-01,2025-01-31")
        return
    try:
        start = datetime.fromisoformat(parts[0])
        end = datetime.fromisoformat(parts[1]) + timedelta(days=1)
    except Exception:
        await message.answer("–ù–µ–≤—ñ—Ä–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.")
        return
    uid = message.from_user.id
    async with aiosqlite.connect(DB_PATH) as db:
        cur_i = await db.execute("SELECT ts,amount FROM incomes WHERE user_id=? AND ts>=? AND ts<? ORDER BY ts", (uid, start.isoformat(), end.isoformat()))
        incomes = await cur_i.fetchall()
        cur_e = await db.execute("SELECT ts,amount,type FROM expenses WHERE user_id=? AND ts>=? AND ts<? ORDER BY ts", (uid, start.isoformat(), end.isoformat()))
        expenses = await cur_e.fetchall()
    text = f"–ó–≤—ñ—Ç –∑–∞ –ø–µ—Ä—ñ–æ–¥ {parts[0]} ‚Äî {parts[1]}:\n\n"
    text += "–î–æ—Ö–æ–¥–∏:\n"
    for r in incomes:
        text += f"- {r[0][:10]}: {r[1]:.2f}\n"
    text += "\n–í–∏—Ç—Ä–∞—Ç–∏:\n"
    for r in expenses:
        text += f"- {r[0][:10]}: {r[2]} {r[1]:.2f}\n"
    bal = sum(r[1] for r in incomes) - sum(r[1] for r in expenses)
    text += f"\n–°–∞–ª—å–¥–æ –∑–∞ –ø–µ—Ä—ñ–æ–¥: {bal:.2f}"
    await message.answer(text, reply_markup=main_keyboard)

# --- –ú—ñ–π –∞–≤—Ç–æ–º–æ–±—ñ–ª—å: –ø–µ—Ä–µ–≥–ª—è–¥ —Ç–∞ —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è (–±–µ–∑ –∑–º—ñ–Ω–∏ –ø—Å–µ–≤–¥–æ–Ω—ñ–º–∞) ---
async def my_car_handler(message: types.Message, state: FSMContext):
    uid = message.from_user.id
    r = await fetchone("SELECT name,nickname,car_model,car_number FROM users WHERE user_id=?", (uid,))
    if not r:
        await message.answer("–í–∏ —â–µ –Ω–µ –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω—ñ.")
        return
    name, nick, car_model, car_number = r
    kb = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="–†–µ–¥–∞–≥—É–≤–∞—Ç–∏ —ñ–º'—è", callback_data="edit:name")],
        [types.InlineKeyboardButton(text="–†–µ–¥–∞–≥—É–≤–∞—Ç–∏ –∞–≤—Ç–æ", callback_data="edit:car")],
        [types.InlineKeyboardButton(text="–ó–∞–∫—Ä–∏—Ç–∏", callback_data="edit:close")]
    ])
    await message.answer(f"üë§ {name}\nüè∑Ô∏è {nick}\nüöò {car_model} ({car_number})", reply_markup=kb)

async def edit_callback(callback: types.CallbackQuery, state: FSMContext):
    await callback.answer()
    _, action = callback.data.split(":",1)
    if action == "name":
        await callback.message.answer("–í–≤–µ–¥—ñ—Ç—å –Ω–æ–≤–µ —ñ–º'—è:")
        await state.set_state(Registration.waiting_for_name)
    elif action == "car":
        await callback.message.answer("–í–≤–µ–¥—ñ—Ç—å –Ω–æ–≤—É –º–∞—Ä–∫—É —Ç–∞ –º–æ–¥–µ–ª—å –∞–≤—Ç–æ:")
        await state.set_state(Registration.waiting_for_car_model)
    elif action == "close":
        await callback.message.delete()
    else:
        await callback.message.answer("–ù–µ–≤—ñ–¥–æ–º–∞ –¥—ñ—è.")

# --- –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è (–º—ñ–Ω—ñ–º–∞–ª—å–Ω–æ: –∑–º—ñ–Ω–∞ –º–æ–≤–∏/–ø–µ—Ä—ñ–æ–¥–∏—á–Ω–æ—Å—Ç—ñ –∑–≤—ñ—Ç—ñ–≤) ---
async def settings_handler(message: types.Message, state: FSMContext):
    kb = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="–ú–æ–≤–∞: –£–∫—Ä–∞—ó–Ω—Å—å–∫–∞", callback_data="setlang:uk")],
        [types.InlineKeyboardButton(text="–ü–µ—Ä—ñ–æ–¥ –∑–≤—ñ—Ç—ñ–≤: –©–æ—Ç–∏–∂–Ω—è", callback_data="setperiod:weekly"),
         types.InlineKeyboardButton(text="–ü–µ—Ä—ñ–æ–¥ –∑–≤—ñ—Ç—ñ–≤: –©–æ–º—ñ—Å—è—Ü—è", callback_data="setperiod:monthly")],
    ])
    await message.answer("–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è:", reply_markup=kb)

async def settings_callback(callback: types.CallbackQuery):
    await callback.answer()
    action, val = callback.data.split(":",1)
    if action == "setlang":
        await execute("UPDATE users SET lang=? WHERE user_id=?", (val, callback.from_user.id))
        await callback.message.answer("–ú–æ–≤—É –∑–±–µ—Ä–µ–∂–µ–Ω–æ.")
    elif action == "setperiod":
        await execute("UPDATE users SET report_period=? WHERE user_id=?", (val, callback.from_user.id))
        await callback.message.answer("–ü–µ—Ä—ñ–æ–¥ –∑–≤—ñ—Ç—ñ–≤ –∑–º—ñ–Ω–µ–Ω–æ.")

# --- –¢–æ–ø –≤–æ–¥—ñ—ó–≤ ---
async def top_drivers_handler(message: types.Message, state: FSMContext):
    rows = await get_top_drivers(limit=10)
    if not rows:
        await message.answer("–ü–æ–∫–∏ —â–æ –Ω–µ–º–∞—î –¥–∞–Ω–∏—Ö –¥–ª—è —Ä–µ–π—Ç–∏–Ω–≥—É.")
        return
    text = "üèÜ –¢–æ–ø –≤–æ–¥—ñ—ó–≤:\n"
    for i, r in enumerate(rows, start=1):
        nick, name, bal = r
        text += f"{i}. {name} ({nick}) ‚Äî {bal:.2f}\n"
    await message.answer(text, reply_markup=main_keyboard)

# --- –†–µ—î—Å—Ç—Ä–∞—Ü—ñ—è —Ö–µ–Ω–¥–ª–µ—Ä—ñ–≤ —É Dispatcher ---
dp.message.register(cmd_start, Command(commands=["start"]))
dp.message.register(process_name, StateFilter(Registration.waiting_for_name))
dp.message.register(process_nickname, StateFilter(Registration.waiting_for_nickname))
dp.message.register(process_car_model, StateFilter(Registration.waiting_for_car_model))
dp.message.register(process_car_number, StateFilter(Registration.waiting_for_car_number))

dp.message.register(add_income_start, lambda m: m.text == "üì• –î–æ–¥–∞—Ç–∏ –∑–∞—Ä–æ–±—ñ—Ç–æ–∫")
dp.message.register(add_income_amount, StateFilter(AddIncome.waiting_for_amount))
dp.message.register(add_expense_start, lambda m: m.text == "üí∏ –î–æ–¥–∞—Ç–∏ –≤–∏—Ç—Ä–∞—Ç–∏")
dp.message.register(add_expense_amount, StateFilter(AddExpense.waiting_for_amount))
dp.callback_query.register(exp_type_callback, lambda c: c.data and c.data.startswith("exp_type:"))

dp.message.register(my_stats_handler, lambda m: m.text == "üìä –ú–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
dp.message.register(report_period_handler, lambda m: "," in m.text and m.text[0].isdigit())  # –ø—Ä–æ—Å—Ç–∏–π catch –¥–ª—è "YYYY-MM-DD,YYYY-MM-DD"
dp.message.register(report_period_start, lambda m: m.text == "üìÖ –ó–≤—ñ—Ç –∑–∞ –ø–µ—Ä—ñ–æ–¥")

dp.message.register(top_drivers_handler, lambda m: m.text == "üèÜ –¢–æ–ø –≤–æ–¥—ñ—ó–≤")
dp.message.register(my_car_handler, lambda m: m.text == "üöò –ú—ñ–π –∞–≤—Ç–æ–º–æ–±—ñ–ª—å")
dp.callback_query.register(edit_callback, lambda c: c.data and c.data.startswith("edit:"))

dp.message.register(settings_handler, lambda m: m.text == "‚öôÔ∏è –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è")
dp.callback_query.register(settings_callback, lambda c: c.data and c.data.startswith("set"))

# --- –ó–∞–ø—É—Å–∫ ---
async def main():
    await init_db()
    try:
        await dp.start_polling(bot)
    finally:
        await bot.session.close()

if __name__ == "__main__":
    asyncio.run(main())
